---
title: "uber"
author: "Valeriy Kondruk"
date: "11 07 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# UBER perks problem


UBER has introduced the new perks for its drivers recently. One of the perks is the full tuition for the ASU online. Driver needs to make 3000 trips to be able t claim this particular perk. I have a data of a driver who has been driving for 43 weeks. At the time the driver had completed 2091 trips. My goal is to calculate the number of weeks this driver would need to drive to get his ASU Online tuition covered by UBER. 

### Outline the research process

We have a data set covering 43 consequtive weeks of driving history - a sample with 43 observations. Using this sample, we want to make an inference about the population (all possible weeks for this particular driver). 

1. Import and clean data
2. Calculate the descriptive statistics, build the distribution plot
3. Calculate confidence interval
4. Find min and max number of weeks to reach the perk  

5. More research questions

#### Import and clean data

```{r echo=FALSE, warning=FALSE, results='hide', message=FALSE, error=FALSE}
library(dplyr)
library(ggplot2)
library(readxl)
library(readr)

# plyr is handy for multiple cvs import 
library(plyr)

# package lubridate for easy date/time handling
install.packages("lubridate")
library(lubridate)
```

We have already imported the data from Excel file and saved as uber_stats.Rdata file.

```{r uber}
# uber_stats <- read_delim("uber_stats.csv", 
#     ";", escape_double = FALSE, na = "NA", 
#     trim_ws = TRUE)
# View(uber_stats)
# save(uber_stats, file = "uber_stats.Rdata")
load("uber_stats.Rdata")
```

We have the weekly data spanning between September 17, 2018 and July 15, 2019. Data for some of the weeks is unavailable as driver didn't drive those weeks. For this research, we will eliminate the empty weeks.

#### Calculate the descriptive statistics, build the distribution plot

```{r}
trips_stat <- uber_stats %>%
  summarise(trips_mean = mean(as.numeric(uber_stats$`Number of trips`), na.rm = TRUE), trips_sd = sd(as.numeric(uber_stats$`Number of trips`), na.rm = TRUE), trips_min = min(as.numeric(uber_stats$`Number of trips`), na.rm = TRUE), trips_max = max(as.numeric(uber_stats$`Number of trips`), na.rm = TRUE))

paid_weeks <- uber_stats %>%
  filter(!is.na(as.numeric(uber_stats$`Number of trips`)), n())

nonzero_weeks_count <- NROW(paid_weeks$`Number of trips`)

# It's hard to pick the right number of bins for the following histogram, so we're using Sturge's Rule (K = 1 + 3. 322 logN). Where K is nthe number of bins and N is the number of observations.

show(1 + 3.322*log(nonzero_weeks_count))

# We need approximately 13 bins for the plot. We ended up with 8, though.

paid_weeks %>%
  ggplot(aes(as.numeric(paid_weeks$`Number of trips`))) +
  geom_histogram(binwidth = 10)

```

We have a nearly normal distribution with a left skew. The mean is 52.5 and standard deviation is 18.3. We doubt if we should use the Poisson distribution instead as we're dealing with the number of event happening in equal and consequtive periods of time. We keep it normal for now.

#### Calculate confidence interval

We are calculating the confidence interval as (point of estimate +- z*SE).

```{r}
SE_trips <- trips_stat$trips_sd / sqrt(nonzero_weeks_count)
z_trips <- abs(qnorm(0.025))
margin_of_error_trips <- z_trips*SE_trips
ci_trips <- trips_stat %>%
  summarise(lower = trips_mean - margin_of_error_trips, upper = trips_mean + margin_of_error_trips)
```

We found our confidence interval at 95% confidence level to be from `r round(ci_trips$lower, 1)` to `r round(ci_trips$upper, 1)` trips per week.

#### Find min and max number of weeks to reach the perk

```{r}
remaining_weeks_min <- round((3000 - 2091) / ci_trips$upper, 1)
remaining_weeks_max <- round((3000 - 2091) / ci_trips$lower, 1)

```

Considering that the rider already made 2091 trips, it will take this driver at least `r remaining_weeks_min` weeks and at most `r remaining_weeks_max` weeks to reach 3000 trips.


## More research questions

### On which day of the week riders tip most frequently?

That would be great to know if there's any correlation between the day of the week and tip amount and frequency a driver gets. For this analysis, we need to get a data set with separate trips (not just weekly data we used before).  


#### Getting data from multiple csvs

We have a raw data in Uber weekly statements that we want to put into one data set. 

```{r multiple_csv error=FALSE, warning=FALSE, message=FALSE, collapse=TRUE}

# We first put all csvs into dedicated folder. Then, we create a list of all files in csv folder.

mydir = "csv"
myfiles = list.files(path=mydir, pattern="*.csv", full.names=TRUE)

# We use ldply function from plyr library to build a data frame from multiple csv files using read_csv function from readr library.

uber_trips = ldply(myfiles, read_csv)
```

Fortunately, raw data already show a day of the week for each trip, so we don't need to take extra steps to transform date into days of the week. However, we would need to split the 'Date/Time' parameter into 'Date/Time' and 'Weekday'.

```{r date_time_separation}
# create new column, convert Date/Time data in a proper format then extract the week day

uber_trips <- uber_trips %>%
  mutate(date_time = as.POSIXct(strptime(uber_trips$`Date/Time`, format = "%A, %B %d, %Y %I:%M %p"))) %>%
  # assign week day: time after midnight (till 5 am) considered a previous day since the shift isn't over 
  mutate(week_day = ifelse(hour(date_time) > 5, weekdays(date_time, abbreviate = TRUE), (weekdays(as.Date(date_time)-1, abbreviate = TRUE))))
```

*Please, note that driver's shift often spans from evening to late night. Thus, for this particular analysis we don't switch the day right after midnight and we keep the same day until 5am in the morning. This way a tip recieved on a Sunday's late night ride considered a Sunday's tip, not Monday's which makes sense.*   

All currency columns need to be converted into numerical format.

```{r change_formats}
# create a function which converts char variable into currency variable
currency <- function(x, na.rm = TRUE) (as.numeric(sub('$','',as.character(x),fixed=TRUE)))

# create a list of all columns to be converted
char_list <- colnames(select_if(uber_trips, is.character))
                      
# exclude all non-currency columns
char_list = char_list[- c(1, 2, 3, 4, 5, 20)]
char_list[15] = "Promotions"
char_list[16] = "Cleaning Repairs"
  
# change the format for currency columns. We use new data frame to avoid any data loss
uber_trips_clean <- uber_trips %>%
  mutate_at(char_list, currency, na.rm = TRUE)
```


#### Summary statistics

Chack summary statistics and parameter distributions.

```{r summary_statistics}
# Summary stats for Tip variable
uber_trips_clean %>% 
  filter(!is.na(Tip)) %>%
  summarise(tip_mean = mean(as.numeric(Tip,  na.rm = TRUE)), tip_min = min(as.numeric(Tip)), tip_max = max(as.numeric(Tip,  na.rm = TRUE)), tip_sd = sd(as.numeric(Tip))) %>%
  show()

uber_trips_clean %>%
  filter(!is.na(Tip)) %>%
  ggplot(aes(x = Tip)) +
  geom_histogram(binwidth = 3) 
```

'Tip' variable represent a right-skewed unimodal distribution with several extreme outliers (more than 3 standard deviations from the mean).

#### Find dyas when tips received most frequently

```{r}
# Build a frequency plot
uber_trips_clean %>%
  filter(!is.na(Tip)) %>%
  ggplot(aes(y = Tip, x = week_day)) +
  geom_bin2d()

# Number of trips with tip and trips per week day
days_stat <- uber_trips_clean %>%
  group_by(week_day) %>%
  summarise(trips_w_tip = sum(!is.na(Tip)), trips_total = n(), proportion = trips_w_tip/trips_total)

days_stat

```

#### ANOVA hypothesis test

It's interesting to check whether the differencies in frequencies are due to chance or not. We'll be using ANOVA test to find out.


